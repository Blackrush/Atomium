package org.atomium.dialects;

import com.googlecode.cqengine.attribute.Attribute;
import com.googlecode.cqengine.query.Query;
import org.atomium.JdbcDatabaseMetadata;
import org.atomium.Ref;
import org.atomium.SqlQuery;
import org.atomium.annotations.Column;
import org.atomium.annotations.PrimaryKey;
import org.atomium.dialects.DefaultSqlDialect;
import org.atomium.metadata.Metadata;
import org.atomium.metadata.SimpleMetadataRegistry;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import java.sql.Connection;
import java.sql.DriverManager;

import static com.googlecode.cqengine.query.QueryFactory.*;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.junit.Assert.assertThat;

/**
 * @author Blackrush
 */
public class DefaultSqlDialectTest {
    @SuppressWarnings("UnusedDeclaration")
    public static final class MyEntity {
        private int id;
        private String attr;

        @Column
        @PrimaryKey(autogenerated = true)
        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        @Column
        public String getAttr() {
            return attr;
        }

        public void setAttr(String attr) {
            this.attr = attr;
        }
    }

    private static Connection connection;

    private Metadata<MyEntity> myEntity;
    private DefaultSqlDialect dialect;

    @BeforeClass
    public static void setUpConnection() throws Exception {
        Class.forName("org.sqlite.JDBC");
        connection = DriverManager.getConnection("jdbc:sqlite::memory:");
    }

    @AfterClass
    public static void tearDownConnection() throws Exception {
        connection.close();
    }

    @Before
    public void setUp() throws Exception {
        myEntity = new SimpleMetadataRegistry().register(MyEntity.class);
        dialect = new DefaultSqlDialect(JdbcDatabaseMetadata.fromJDBC(connection.getMetaData()));
    }

    @Test
    public void testBuildStructure() throws Exception {
        SqlQuery query = dialect.buildStructure(myEntity);

        // use TEXT instead of VARCHAR(255) here because of SQLite
        assertThat(query.getCommand(), is("CREATE TABLE `myEntity`(`id` INTEGER PRIMARY KEY AUTOINCREMENT, `attr` TEXT NOT NULL);"));
        assertThat(query.getBoundValues().length(), is(0));
    }

    @Test
    public void testCreate() throws Exception {
        MyEntity entity = new MyEntity();
        entity.attr = "hello world";
        SqlQuery query = dialect.create(myEntity, entity);

        assertThat(query.getCommand(), is("INSERT INTO `myEntity`(`id`, `attr`) VALUES(:id, :attr);"));

        assertThat(query.getBoundValues().length(), is(2));
        assertThat(query.getBoundValue("attr"), is((Object) entity.attr));
        assertThat(query.getBoundValue("id"), nullValue());
    }

    @Test
    public void testRead() throws Exception {
        SqlQuery query = dialect.read(myEntity);
        assertThat(query.getCommand(), is("SELECT `id`, `attr` FROM `myEntity`;"));
        assertThat(query.getBoundValues().length(), is(0));
    }

    @Test
    public void testReadQuery() throws Exception {
        Attribute<MyEntity, Comparable> id = myEntity.getPrimaryKey().asAttribute();
        Attribute<MyEntity, CharSequence> attr = myEntity.getColumn("attr").asAttribute();

        Query<MyEntity> q = and(greaterThan(id, 1000), startsWith(attr, "LEL"));

        SqlQuery query = dialect.read(myEntity, q);

        assertThat(query.getCommand(), is("SELECT `id`, `attr` FROM `myEntity` WHERE `id` > 1000 AND `attr` LIKE 'LEL%';"));
        assertThat(query.getBoundValues().length(), is(0));
    }

    @Test
    public void testReadRef() throws Exception {
        Ref<MyEntity> ref = myEntity.getColumn("attr").getRef("lel");
        SqlQuery query = dialect.read(ref);

        assertThat(query.getCommand(), is("SELECT `id`, `attr` FROM `myEntity` WHERE `attr`=:attr;"));

        assertThat(query.getBoundValues().length(), is(1));
        assertThat(query.getBoundValue("attr"), is((Object) "lel"));
    }

    @Test
    public void testUpdate() throws Exception {
        SqlQuery query = dialect.update(myEntity, new MyEntity());

        assertThat(query.getCommand(), is("UPDATE `myEntity` SET `attr`=:attr WHERE `id`=:id;"));

        assertThat(query.getBoundValues().length(), is(2));
        assertThat(query.getBoundValue("attr"), nullValue());
        assertThat(query.getBoundValue("id"), is((Object) 0));
    }

    @Test
    public void testDelete() throws Exception {
        SqlQuery query = dialect.delete(myEntity, new MyEntity());

        assertThat(query.getCommand(), is("DELETE FROM `myEntity` WHERE `id`=:id;"));

        assertThat(query.getBoundValues().length(), is(1));
        assertThat(query.getBoundValue("id"), is((Object) 0));
    }

    @Test
    public void testDeleteRef() throws Exception {
        Ref<MyEntity> ref = myEntity.getColumn("attr").getRef("lel");
        SqlQuery query = dialect.delete(ref);

        assertThat(query.getCommand(), is("DELETE FROM `myEntity` WHERE `attr`=:attr;"));

        assertThat(query.getBoundValues().length(), is(1));
        assertThat(query.getBoundValue("attr"), is((Object) "lel"));
    }
}
